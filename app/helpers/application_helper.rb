module ApplicationHelper
  FLASH_NOTICE_CLASSES = {
    :info    => :info,
    :warning => :warning,
    :success => :success,
    :error   => :errormsg,
    :notice  => :info
  }

  # Use this to display the flash. When setting the flash you should use any of
  #
  #   flash[:info]
  #   flash[:warning]
  #   flash[:error]
  #   flash[:success]
  #
  # flash[:notice] is assumed to be the same as flash[:info]
  #
  def flash_notice
    @flash_rendered = true
    [:info, :warning, :error, :success, :notice].collect do |level|
      notice_box level, content_tag(:p, flash[level]) if flash[level].present?
    end.compact.join
  end
  
  def notice_box(level, message)
    content_tag :div, message, :class => "message #{FLASH_NOTICE_CLASSES[level]}"
  end
  
  def flash_rendered?
    @flash_rendered || false
  end

  # Error messages formatted for Adminus.
  #
  # Options are:
  #   :message => nil : Message to announce in the flash notice style error box.
  #   :include_errors => false : Whether or not to include field specific errors in the error box.
  #   :object_name => (actual object name) : used in the default :message 
  def error_messages_for(*params)
    options = params.extract_options!.symbolize_keys
    
    if object = options.delete(:object)
      objects = Array.wrap(object)
    else
      objects = params.collect {|object_name| instance_variable_get("@#{object_name}") }.compact
    end

    count  = objects.inject(0) {|sum, object| sum + object.errors.count }
    unless count.zero?
      options[:object_name] ||= params.first

      I18n.with_options :locale => options[:locale], :scope => [:activerecord, :errors, :template] do |locale|
        message =
          if options[:message]
            options[:message]
          else
            options[:object_name] ||= params.first
            object_name = options[:object_name].to_s
            object_name = I18n.t(object_name, :default => object_name.gsub('_', ' '), :scope => [:activerecord, :models], :count => 1)
            locale.t :header, :count => count, :model => object_name
          end
        
        contents = ''
        contents << content_tag(:p, message) unless message.blank?

        if options[:include_errors]
          error_messages = objects.sum {|object| object.errors.full_messages.map {|msg| content_tag(:li, ERB::Util.html_escape(msg)) } }.join
          contents << content_tag(:ul, error_messages)
        end
        
        notice_box :error, contents
      end
    else
      ''
    end
    
  end

  # widget_box is responsible for drawing a box to the page. This is the
  # one you will always use.
  #
  # If you need tabs you should call widget_tab inside of your widget_box
  # call. You could pre-generate the tabs and then pass them in as :tabs
  # but I recommend against it.
  #
  # Options:
  #   :box => Hash of options to pass to the outer box generator.
  #   :tabs => Array of tabs generated by widget_tab.
  #   :header_html => A string representing the arbitrary html to render
  #     in the header.
  def widget_box(title, options = {}, &block)
    raise "Bad developer. No nested widget boxes for you!" if @rendering_widget_box
    @rendering_widget_box = true

    # This is where we're going to drop any tabs generated in our block.
    @widget_options = {
      :tabs         => [],
      :header_html  => nil,
      :sidebar_html => nil,
      :orientation  => options[:orientation] || :horizontal
    }

    # Now render the page and see what happens
    content = widget_content options, &block

    # Now we've got tabs and everything else so let's render the rest of the box.
    header  = widget_header title, options
    footer  = widget_footer options

    # And now the box options
    options.reverse_merge! :box => {}
    add_class! options[:box], :block
    add_class! options[:box], :withsidebar if vertical_tabs?

    # Put it all together
    concat content_tag(:div, header + content + footer, options[:box])
    
    # Cleanup
    @widget_options       = nil
    @rendering_widget_box = false
  end

  # Renders the header for widget box.
  def widget_header(title, options = {})
    pre_title = '<div class="bheadl"></div><div class="bheadr"></div>'.html_safe
    title     = content_tag :h2, title

    right =
      if @widget_options[:header_html]
        @widget_options[:header_html]
      else
        tabs = @widget_options[:tabs] || options[:tabs]

        if tabs.present? && horizontal_tabs?
          tabs_to_list tabs, :ul => { :class => :tabs }
        else
          ''
        end
      end
    
    content_tag :div, pre_title + title + right, :class => :block_head
  end

  def widget_footer(options = {})
    '<div class="bendl"></div><div class="bendr"></div>'.html_safe
  end

  # Decorates a content block.
  def widget_content(options = {}, &block)
    
    # Do we need to generate the tabs first?
    unformatted_content = capture &block if block_given?

    # Do we have tabs?
    tabs = @widget_options[:tabs] || options[:tabs]

    if tabs.present?
      tab_class = vertical_tabs? ? :sidebar_content : "block_content tab_content"
      tab_html  = tabs.collect { |tab| content_tag :div, tab.content, :class => tab_class, :id => tab.id }.join

      # Do we need to make the sidebar as well?
      if vertical_tabs?
        list = tabs_to_list tabs, :ul => { :class => :sidemenu }
        pre_content = content_tag :div, list + (@widget_options[:sidebar_html] || ''), :class => :sidebar

        content_tag :div, pre_content + tab_html, :class => :block_content
      else
        tab_html
      end
    else
      raise ArgumentError, "Block required" unless block_given?
      content_tag :div, unformatted_content, :class => :block_content
    end
  end
  
  def tabs_to_list(tabs, options = {})
    options.reverse_merge! :ul => {}
    elements = tabs.collect { |tab| content_tag :li, tab.link } .join
    content_tag :ul, elements, options[:ul]
  end

  def vertical_tabs?
    @widget_options[:orientation] == :vertical
  end
  
  def horizontal_tabs?
    @widget_options[:orientation] == :horizontal
  end
  
  # Adds a WidgetTab object to the current render set.
  def widget_tab(tab, id, &block)
    @widget_options[:tabs] << WidgetTab.new(:id => id, :tab => tab, :content => capture(&block), :template => self)
  end
  
  # Adds a WidgetHeaderLink object to the current render set.
  def widget_header_link(title, href, options = {})
    @widget_options[:header_links] << WidgetHeaderLink.new(:text => title, :href => href, :options => options, :template => self)
  end
  
  # Adds arbitrary header html to the current block
  def widget_header_html(&block)
    @widget_options[:header_html] = content_tag :div, capture(&block), :class => :header_right
  end
  
  # Adds arbitrary sidebar html to the current block. Only visible with veritcal tabs.
  def widget_sidebar(&block)
    @widget_options[:sidebar_html] = capture(&block)
  end

  # Adds a class to a hash of options unless it already exists.
  def add_class!(options, class_name)
    options[:class] = (options[:class] || '').to_s
    options[:class] << " #{class_name}" unless options[:class] =~ /\b#{options[:class]}\b/
  end

  class WidgetItem
    attr_accessor :options
    
    def initialize(options)
      self.options = options.reverse_merge(:template => nil)
    end

    private
    
      def method_missing(method_id, *args)
        method_id.to_s =~ /^([a-z_]+)(=)?$/
        assignment = $2.present?

        if self.options.has_key? method_id
          if assignment
            self.options[method_id] = args.first
          else
            self.options[method_id]
          end
        else
          super
        end
      end

  end

  class WidgetTab < WidgetItem
    def initialize(options)
      super options.reverse_merge(:id => nil, :tab => nil, :content => nil)
    end
    
    def id
      options[:id]
    end
    
    def link
      template.link_to tab, "\##{id}"
    end
  end
  
end
